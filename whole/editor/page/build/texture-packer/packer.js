function trimImages(e,t,i){Fs.ensureDirSync(tmpDir);let r=0;Async.forEach(e,function(e,t){e.originalPath=e.path,e.path=Path.join(tmpDir,"spritesheet_js_"+(new Date).getTime()+"_image_"+r+++".png");let i=e.trim,a=Sharp(e.originalPath).extract({left:i.x,top:i.y,width:i.rotatedWidth,height:i.rotatedHeight});e.spriteFrame.isRotated()&&(a=a.rotate(270)),a.toFile(e.path,function(i){i&&Editor.error(`trimImages [${e.spriteFrame.name}] from [${e.originalPath}]  failed`),t(i)})},i)}function determineAtlasSize(e,t,i){let r=e.concat();for(;r.length>0;){let e=new MaxRectsBinPack(t.width,t.height,t.allowRotation),i=e.insertRects(r,MaxRectsBinPack.heuristices[t.heuristices]);if(0===e.usedRectangles.length){t.unpackedTextures=r;break}let a=0,n=0;for(let e=0;e<i.length;e++){let t=i[e];t.rotatedWidth=t.rotated?t.height:t.width,t.rotatedHeight=t.rotated?t.width:t.height,t.trim.rotatedWidth=t.rotated?t.trim.height:t.trim.width,t.trim.rotatedHeight=t.rotated?t.trim.width:t.trim.height;let r=t.x+t.rotatedWidth,o=t.y+t.rotatedHeight;r>a&&(a=r),o>n&&(n=o)}t.atlases.push({width:a,height:n,files:i})}t.files=[],t.atlases.forEach(function(e){applySquareAndPowerConstraints(e,t.square,t.powerOfTwo),e.files.forEach(e=>{e.trim.x=e.x+t.padding+t.bleed,e.trim.y=e.y+t.padding+t.bleed}),t.files=t.files.concat(e.files)}),i(null,t)}function applySquareAndPowerConstraints(e,t,i){t&&(e.width=e.height=Math.max(e.width,e.height)),i&&(e.width=roundToPowerOfTwo(e.width),e.height=roundToPowerOfTwo(e.height))}function generateAtlas(e,t,i){let r=t.format,a=e.files,n=e.imagePath=t.path+"/"+t.name+"."+t.format;"jpg"===r&&(r="jpeg");const o=t.width,h=t.height,d={raw:{width:o,height:h,channels:4}};let s=Buffer.alloc(o*h*4,0),l=Sharp(s,d).toBuffer();for(let e=0;e<a.length;e++){let t=a[e],i=t.trim.x,r=t.trim.y;l=l.then(e=>t.rotated?Sharp(t.path).rotate(90).toBuffer().then(t=>Sharp(e,d).overlayWith(t,{left:i,top:r}).toBuffer().then(e=>new Promise(function(t,i){process.nextTick(()=>{t(e)})}))):Sharp(e,d).overlayWith(t.path,{left:i,top:r}).toBuffer().then(e=>new Promise(function(t,i){process.nextTick(()=>{t(e)})}))).catch(e=>{Editor.error(`Handle image [${t.path} error]. \n Origin path is [${t.originalPath}:${t.spriteFrame.name}]. \n Error : ${e.toString()}`)})}(t.contourBleed||t.paddingBleed)&&(l=l.then(i=>new Promise(function(r,a){process.nextTick(()=>{let a=i;applyBleed(t,e,i,a),r(a)})}))),l.then(e=>Sharp(e,d)[r](0|t.quality).toFile(n,function(t){e=null,i(t)})).catch(e=>{i(e)})}function unlinkTempFiles(e){try{Del(tmpDir,{force:!0},e)}catch(e){return Editor.error(e),void 0}}function roundToPowerOfTwo(e){if("number"!=typeof e)return;let t=2;for(;e>t;)t*=2;return t}const Fs=require("fire-fs"),Async=require("async"),Path=require("fire-path"),Del=require("del"),Sharp=require(Editor.url("app://editor/share/sharp")),MaxRectsBinPack=require("./packing/maxrects"),applyBleed=require("./bleeding").applyBleed,tmpDir=Path.join(Editor.remote.projectInfo.path,"temp","trimImages");module.exports=function(e,t,i){if(!e||0===e.length)return i(new Error("no spriteFrames specified"));(t=t||{}).name=t.name||"spritesheet",t.path=Path.resolve(t.path||"."),t.square="boolean"==typeof t.square&&t.square,t.powerOfTwo="boolean"==typeof t.powerOfTwo&&t.powerOfTwo,t.padding="number"==typeof t.padding?t.padding:0,t.heuristices="string"==typeof t.heuristices?t.heuristices:"BestAreaFit",t.format="string"==typeof t.format?t.format:"png",t.quality="number"==typeof t.quality?t.quality:80,t.contourBleed="boolean"==typeof t.contourBleed&&t.contourBleed,t.paddingBleed="boolean"==typeof t.paddingBleed&&t.paddingBleed,t.bleed=t.paddingBleed?1:0;let r=e.map(e=>{let i=e.getTexture(),r=i.url,a=e.getRect();return a.rotatedWidth=e.isRotated()?a.height:a.width,a.rotatedHeight=e.isRotated()?a.width:a.height,{name:Path.basenameNoExt(r),spriteFrame:e,uuid:e._uuid,textureUuid:i._uuid,path:r,trim:a,rawWidth:e.getOriginalSize().width,rawHeight:e.getOriginalSize().height,width:a.width+2*(t.padding+t.bleed),height:a.height+2*(t.padding+t.bleed)}});Fs.existsSync(t.path)||""===t.path||Fs.mkdirSync(t.path),t.atlases=[],t.unpackedTextures=[],Sharp.cache(!1),console.time("TexturePacker: packer"),Async.waterfall([function(e){r=r.filter(e=>e.trim.width>0&&e.trim.height>0||(e.width=e.rawWidth,e.height=e.rawHeight,t.unpackedTextures.push(e),!1)),e()},function(e){console.time("TexturePacker: trim images"),trimImages(r,t,e)},function(e){console.timeEnd("TexturePacker: trim images"),process.nextTick(function(){e(void 0,r)})},function(e,i){console.time("TexturePacker: determine canvas size"),determineAtlasSize(e,t,i)},function(e,t){console.timeEnd("TexturePacker: determine canvas size"),console.time("TexturePacker: generate images");let i=0,r=e.width,a=e.height,n=e.name;Async.eachSeries(e.atlases,function(t,r){global.gc&&global.gc(),e.name=t.name=n+"-"+ ++i,e.width=t.width,e.height=t.height,generateAtlas(t,e,r)},function(i){console.timeEnd("TexturePacker: generate images"),t(i,e)}),e.name=n,e.width=r,e.height=a},function(e,t){unlinkTempFiles(i=>{t(i,e)})}],(e,t)=>{global.gc&&global.gc(),console.timeEnd("TexturePacker: packer"),i(e,t)})};